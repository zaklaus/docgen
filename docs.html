<html><head><title>Test Sample</title><style>body{background-color:#f5f5f5;font-family:sans-serif}.Page{width:800px;margin:0 auto}p{font-size:15px}h1,h2{color:green}a{text-decoration:none;color:green}a:hover{background-color:#faebd7}ul{list-style:none}pre{font-family:monospace;background-color:#fdf5e6;padding:10px;border:1px solid grey}table{border:1px solid grey;background-color:#fdf5e6;border-collapse:collapse}tr{border-bottom:1px solid grey}th{text-align:left;background-color:#ffe4c4;padding:5px;border-right:1px solid grey}td{padding:5px;border-right:1px solid grey}</style></head><body><div class="Page"><div class="Overview"><h1>$ Overview</h1><p>Contrary to popular belief, Lorem Ipsum is not simply random text. It has roots in a piece of classical Latin literature from 45 BC, making it over 2000 years old. Richard McClintock, a Latin professor at Hampden-Sydney College in Virginia, looked up one of the more obscure Latin words, consectetur, from a Lorem Ipsum passage, and going through the cites of the word in classical literature, discovered the undoubtable source. Lorem Ipsum comes from sections 1.10.32 and 1.10.33 of "de Finibus Bonorum et Malorum" (The Extremes of Good and Evil) by Cicero, written in 45 BC. This book is a treatise on the theory of ethics, very popular during the Renaissance. The first line of Lorem Ipsum, "Lorem ipsum dolor sit amet..", comes from a line in section 1.10.32.

The standard chunk of Lorem Ipsum used since the 1500s is reproduced below for those interested. Sections 1.10.32 and 1.10.33 from "de Finibus Bonorum et Malorum" by Cicero are also reproduced in their exact original form, accompanied by English versions from the 1914 translation by H. Rackham.</p></div><h1>$ Index</h1><ul><h2>Memory Arena</h2><li> <a href="#arena_header">arena_header</a> &nbsp; <small>Describes arena elements.</small></li><li> <a href="#memory_arena">memory_arena</a> &nbsp; <small>Memory arena holding contigous block of memory and tracking of pushed objects.</small></li><li> <a href="#arena_flags">arena_flags</a> &nbsp; <small>Arena flags.</small></li><li> <a href="#temp_memory">temp_memory</a> &nbsp; <small>Used to temporarily store short-living data in arena.</small></li><li> <a href="#arena_push_flag">arena_push_flag</a> &nbsp; <small>Push flags used by arena allocator.</small></li><li> <a href="#arena_push_params">arena_push_params</a> &nbsp; <small>Params used by allocator for customized allocation procedure.</small></li><li> <a href="#tag_scan_result">tag_scan_result</a> &nbsp; <small>Holds pointer to current element found by specified tag identification.</small></li><br><li> <a href="#ArenaGetBlock">ArenaGetBlock</a> &nbsp; <small>Returns block of memory pointed to by index. *NOTE* Works only with arena`s elements of uniform size!</small></li><li> <a href="#ArenaGetVaryBlock">ArenaGetVaryBlock</a> &nbsp; <small>Returns element by index.</small></li><li> <a href="#ArenaGetVaryBlockTagValue">ArenaGetVaryBlockTagValue</a> &nbsp; <small>Returns element`s value by tag.</small></li><li> <a href="#ArenaGetVaryBlockTagResult">ArenaGetVaryBlockTagResult</a> &nbsp; <small>Returns tag scan result by tag.</small></li><li> <a href="#ArenaPushStruct">ArenaPushStruct</a> &nbsp; <small>Push struct to the arena.</small></li><li> <a href="#ArenaPushArray">ArenaPushArray</a> &nbsp; <small>Push array to the arena.</small></li><li> <a href="#ArenaPushSize">ArenaPushSize</a> &nbsp; <small>Push size to the arena.</small></li><li> <a href="#ArenaPushCopy">ArenaPushCopy</a> &nbsp; <small>Push and copy size from the source.</small></li><li> <a href="#ArenaPushValue">ArenaPushValue</a> &nbsp; <small>Push and set value to the arena.</small></li><br><li> <a href="#ArenaDefaultTagScan">ArenaDefaultTagScan</a> &nbsp; <small>Default scan setup for new scans.</small></li><li> <a href="#ArenaInitialize">ArenaInitialize</a> &nbsp; <small>Initializes Memory Arena with default values.</small></li><li> <a href="#ArenaBuild">ArenaBuild</a> &nbsp; <small>(null)</small></li><li> <a href="#ArenaGetAlignmentOffset">ArenaGetAlignmentOffset</a> &nbsp; <small>Calculates the offset required by specified alignment.</small></li><li> <a href="#ArenaDefaultParams">ArenaDefaultParams</a> &nbsp; <small>Returns default push state params.</small></li><li> <a href="#ArenaAlignNoClear">ArenaAlignNoClear</a> &nbsp; <small>Returns alignment arena push params without clear flag.</small></li><li> <a href="#ArenaAlign">ArenaAlign</a> &nbsp; <small>Returns alignment arena push params.</small></li><li> <a href="#ArenaNoClear">ArenaNoClear</a> &nbsp; <small>Returns arena push params without clear flag.</small></li><li> <a href="#ArenaExpect">ArenaExpect</a> &nbsp; <small>Returns arena push params with expected reserves.</small></li><li> <a href="#ArenaAlignExpect">ArenaAlignExpect</a> &nbsp; <small>Returns arena push params with expected reserves and alignment.</small></li><li> <a href="#ArenaTag">ArenaTag</a> &nbsp; <small>Returns arena push params with tag property.</small></li><li> <a href="#ArenaGetSizeRemaining">ArenaGetSizeRemaining</a> &nbsp; <small>Returns the remaining unused space size in arena.</small></li><li> <a href="#ArenaGetBlockByRecord">ArenaGetBlockByRecord</a> &nbsp; <small>Returns block of memory pointed to by index.</small></li><li> <a href="#ArenaGetBlockByTagAndRecord">ArenaGetBlockByTagAndRecord</a> &nbsp; <small>Returns tag scan result based on specified tag.</small></li><li> <a href="#ArenaGetEffectiveSizeFor">ArenaGetEffectiveSizeFor</a> &nbsp; <small>Returns effective size based on push params for specified initial size.</small></li><li> <a href="#ArenaHasRoomFor">ArenaHasRoomFor</a> &nbsp; <small>Returns truth value determining whether we have enough space in our arena depending on initial size requirements and push params.</small></li><li> <a href="#ArenaExpand">ArenaExpand</a> &nbsp; <small>Expands the arena if the requested size can`t make it into our arena.</small></li><li> <a href="#ArenaPushSize_">ArenaPushSize_</a> &nbsp; <small>Asks our arena for plotting a block of memory determined by initial size and params requirements.</small></li><li> <a href="#ArenaPushString">ArenaPushString</a> &nbsp; <small>Pushes null-terminated string to the arena.</small></li><li> <a href="#ArenaPushAndNullTerminate">ArenaPushAndNullTerminate</a> &nbsp; <small>Pushes string of specified size to the arena and additionally null-terminates it.</small></li><li> <a href="#ArenaBeginTemporaryMemory">ArenaBeginTemporaryMemory</a> &nbsp; <small>Tells our arena we plan to store temporary memory in it.</small></li><li> <a href="#ArenaEndTemporaryMemory">ArenaEndTemporaryMemory</a> &nbsp; <small>Tells our arena we`re done serving temporary memory and resets it back to its original state.</small></li><li> <a href="#ArenaClear">ArenaClear</a> &nbsp; <small>Clears the whole arena.</small></li><li> <a href="#ArenaCheck">ArenaCheck</a> &nbsp; <small>Checks whether our arena is still holding temporary data.</small></li><li> <a href="#ArenaSub">ArenaSub</a> &nbsp; <small>Creates sub-arena inside of our arena, with specified size and push params.</small></li><li> <a href="#ArenaCleanUnusedRoom">ArenaCleanUnusedRoom</a> &nbsp; <small>Clean unused reserved space in our arena.</small></li><li> <a href="#ArenaFree">ArenaFree</a> &nbsp; <small>Deallocate our arena.</small></li><li> <a href="#ArenaSerialize">ArenaSerialize</a> &nbsp; <small>Serializes our arena</small></li><li> <a href="#ArenaDeserialize">ArenaDeserialize</a> &nbsp; <small>Deserializes our packed data to our new arena.</small></li><li> <a href="#ArenaDuplicate">ArenaDuplicate</a> &nbsp; <small>Duplicates our arena.</small></li></ul><h1>$ Content</h1><ul><div id="arena_header" class="doc"><h2>arena_header</h2><pre>struct
{
    s32 Size;    // Size of the element.
    u32 Tag;     // Element's tag used for identification.
    u32 Offset;  // Memory offset from the base.
    b32 IsFree;  // Is this node free for use?
} arena_header</pre><p>Describes arena elements.</p></div><div id="memory_arena" class="doc"><h2>memory_arena</h2><pre>struct
{
    memory_index Size;             // Allocated memory size. 
    uint8 *Base;                   // Memory base pointer. (Points to a contigous block of memory.)
    memory_index Used;             // Memory already used by elements.
    u8 Flags;                      // Arena's flags.
    b32 WasExpanded;               // If reallocation is allowed, this signals us whether memory expansion has happened.

    s32 TempCount;                 // Counts how many times is our arena used by temp_memory.
    s32 NodeCount;                 // Counts how many nodes do we track in our arena header.
    
    Node_arena_header *Header;     // Linked list of tracked elements.
    Node_arena_header *HeaderEnd;
} memory_arena</pre><p>Memory arena holding contigous block of memory and tracking of pushed objects.</p></div><div id="arena_flags" class="doc"><h2>arena_flags</h2><pre>enum
{
    ArenaFlag_AllowRealloc = (1 << 1),    // Allows re-allocation of the memory, if expansion is required.
    ArenaFlag_DisallowHeaders = (1 << 2), // Disallows tracking of elements. Useful if elements are of uniform size. This also disables Arena memory reuse.
    ArenaFlag_DisallowReuse = (1 << 3),   // Disallows the ability to reuse freed memory in arena.
} arena_flags</pre><p>Arena flags.</p></div><div id="temp_memory" class="doc"><h2>temp_memory</h2><pre>struct
{
    memory_arena *Arena;  // Memory Arena to be used.
    memory_index Used;    // This holds the Arena's original used size.
} temp_memory</pre><p>Used to temporarily store short-living data in arena.</p></div><div id="arena_push_flag" class="doc"><h2>arena_push_flag</h2><pre>enum
{
    ArenaPushFlag_ClearToZero = 0x1,  // Tell the allocator to clear allocated memory.
} arena_push_flag</pre><p>Push flags used by arena allocator.</p></div><div id="arena_push_params" class="doc"><h2>arena_push_params</h2><pre>struct
{
    u32 Flags;        // Specifies push flags. @see arena_push_flag
    u32 Alignment;    // Specifies memory alignment requirements.
    u32 Expectation;  // This tells the allocator to check whether we have enough reserved memory up-front.
    u32 Tag;          // Tag used for identification in pushed element.
} arena_push_params</pre><p>Params used by allocator for customized allocation procedure.</p></div><div id="tag_scan_result" class="doc"><h2>tag_scan_result</h2><pre>struct
{
    u8 *Value;                // Pointer to memory tagged by identification.
    Node_arena_header *Node;  // Pointer to found element.
} tag_scan_result</pre><p>Holds pointer to current element found by specified tag identification.</p></div><div id="ArenaGetBlock" class="doc"><h2>ArenaGetBlock</h2><p>Returns block of memory pointed to by index. *NOTE* Works only with arena`s elements of uniform size!</p><b>Example:</b> <code>(Type *) ArenaGetBlock(Arena, Type, Index)</code></div><div id="ArenaGetVaryBlock" class="doc"><h2>ArenaGetVaryBlock</h2><p>Returns element by index.</p><b>Example:</b> <code>(Type *) ArenaGetVaryBlock(Arena, Type, Index)</code></div><div id="ArenaGetVaryBlockTagValue" class="doc"><h2>ArenaGetVaryBlockTagValue</h2><p>Returns element`s value by tag.</p><b>Example:</b> <code>(Type *) ArenaGetVaryBlockTagValue(Arena, Scan, Type, Tag)</code></div><div id="ArenaGetVaryBlockTagResult" class="doc"><h2>ArenaGetVaryBlockTagResult</h2><p>Returns tag scan result by tag.</p><b>Example:</b> <code>tag_scan_result ArenaGetVaryBlockTagResult(Arena, Scan, Tag)</code></div><div id="ArenaPushStruct" class="doc"><h2>ArenaPushStruct</h2><p>Push struct to the arena.</p><b>Example:</b> <code>(Type *) ArenaPushStruct(Arena, Type, ...)</code></div><div id="ArenaPushArray" class="doc"><h2>ArenaPushArray</h2><p>Push array to the arena.</p><b>Example:</b> <code>(Type *) ArenaPushArray(Arena, Count, Type, ...)</code></div><div id="ArenaPushSize" class="doc"><h2>ArenaPushSize</h2><p>Push size to the arena.</p><b>Example:</b> <code>(void *) ArenaPushSize(Arena, Size, ...)</code></div><div id="ArenaPushCopy" class="doc"><h2>ArenaPushCopy</h2><p>Push and copy size from the source.</p><b>Example:</b> <code>(void *) ArenaPushCopy(Arena, Size, Source, ...)</code></div><div id="ArenaPushValue" class="doc"><h2>ArenaPushValue</h2><p>Push and set value to the arena.</p><b>Example:</b> <code>(none) 
            ArenaPushValue(Arena, Type, Value, ...)</code></div><div id="ArenaDefaultTagScan" class="doc"><h2>ArenaDefaultTagScan</h2><pre>tag_scan_result
ArenaDefaultTagScan(void)
</pre><p>Default scan setup for new scans.</p></div><div id="ArenaInitialize" class="doc"><h2>ArenaInitialize</h2><pre>void
ArenaInitialize(memory_arena *Arena, // Arena to be initialized.
                memory_index Size,   // Size of the allocated memory.
                void *Base)          // Memory block to be used with Arena.
</pre><p>Initializes Memory Arena with default values.</p><b>Example:</b> <code>ArenaInitialize(Arena, 128, MemBlock)</code></div><div id="ArenaBuild" class="doc"><h2>ArenaBuild</h2><pre>void
ArenaBuild(memory_arena *Arena, // Arena to be built.
           memory_index Size)   // The size to be pre-allocated.
</pre><b>Example:</b> <code>Uses allocator to build new arena.)
ArenaBuild(Arena, 128)</code></div><div id="ArenaGetAlignmentOffset" class="doc"><h2>ArenaGetAlignmentOffset</h2><pre>memory_index
ArenaGetAlignmentOffset(memory_arena *Arena,     // Target Arena.
                        memory_index Alignment)  // Desired alignment
</pre><p>Calculates the offset required by specified alignment.</p><b>Example:</b> <code>ArenaGetAlignmentOffset(Arena, 8)</code></div><div id="ArenaDefaultParams" class="doc"><h2>ArenaDefaultParams</h2><pre>arena_push_params
ArenaDefaultParams(void)
</pre><p>Returns default push state params.</p></div><div id="ArenaAlignNoClear" class="doc"><h2>ArenaAlignNoClear</h2><pre>arena_push_params
ArenaAlignNoClear(
u32 Alignment)      // Memory alignment we require during allocation.
</pre><p>Returns alignment arena push params without clear flag.</p></div><div id="ArenaAlign" class="doc"><h2>ArenaAlign</h2><pre>arena_push_params
ArenaAlign(u32 Alignment, // Memory alignment we require during allocation.
           b32 Clear)     // Should allocator clear allocated memory?
</pre><p>Returns alignment arena push params.</p></div><div id="ArenaNoClear" class="doc"><h2>ArenaNoClear</h2><pre>arena_push_params
ArenaNoClear(void)
</pre><p>Returns arena push params without clear flag.</p></div><div id="ArenaExpect" class="doc"><h2>ArenaExpect</h2><pre>arena_push_params
ArenaExpect(u32 Expectation, // Expected memory to be in reserves.
            b32 Clear)       // Should allocator clear allocated memory?
</pre><p>Returns arena push params with expected reserves.</p></div><div id="ArenaAlignExpect" class="doc"><h2>ArenaAlignExpect</h2><pre>arena_push_params
ArenaAlignExpect(u32 Alignment,   // Memory alignment we require during allocation.
                 u32 Expectation, // Expected memory to be in reserves.
                 b32 Clear)       // Should allocator clear allocated memory?
</pre><p>Returns arena push params with expected reserves and alignment.</p></div><div id="ArenaTag" class="doc"><h2>ArenaTag</h2><pre>arena_push_params
ArenaTag(u32 Tag,                 // Tag used for element lookup.
         arena_push_params Rest)  // Rest of the push params. @see arena_push_params
</pre><p>Returns arena push params with tag property.</p></div><div id="ArenaGetSizeRemaining" class="doc"><h2>ArenaGetSizeRemaining</h2><pre>memory_index
ArenaGetSizeRemaining(memory_arena *Arena,      // Target arena
                      arena_push_params Params) // Params to be used during the procedure.
</pre><p>Returns the remaining unused space size in arena.</p></div><div id="ArenaGetBlockByRecord" class="doc"><h2>ArenaGetBlockByRecord</h2><pre>void *
ArenaGetBlockByRecord(memory_arena *Arena, // Target arena
                      size_t Index)        // Element index
</pre><p>Returns block of memory pointed to by index.</p></div><div id="ArenaGetBlockByTagAndRecord" class="doc"><h2>ArenaGetBlockByTagAndRecord</h2><pre>tag_scan_result
ArenaGetBlockByTagAndRecord(memory_arena *Arena,  // Target arena
                            tag_scan_result scan, // Previous scan result. (Or DefaultTagScan if none. @see DefaultTagScan)
                            u32 Tag)              // Tag used for lookup.
</pre><p>Returns tag scan result based on specified tag.</p></div><div id="ArenaGetEffectiveSizeFor" class="doc"><h2>ArenaGetEffectiveSizeFor</h2><pre>memory_index
ArenaGetEffectiveSizeFor(memory_arena *Arena,      // Target arena
                         memory_index SizeInit,    // Initial size required by callee.
                         arena_push_params Params) // Params to be used during the procedure.
</pre><p>Returns effective size based on push params for specified initial size.</p></div><div id="ArenaHasRoomFor" class="doc"><h2>ArenaHasRoomFor</h2><pre>b32
ArenaHasRoomFor(memory_arena *Arena,       // Target arena
                memory_index SizeInit,     // Initial size required by callee.
                arena_push_params Params)  // Params to be used during the procedure.
</pre><p>Returns truth value determining whether we have enough space in our arena depending on initial size requirements and push params.</p></div><div id="ArenaExpand" class="doc"><h2>ArenaExpand</h2><pre>void *
ArenaReuseMem(memory_arena *Arena,
              memory_index Size,
              b32 *IsReused,
              arena_push_params Params)
</pre><p>Expands the arena if the requested size can`t make it into our arena.</p></div><div id="ArenaPushSize_" class="doc"><h2>ArenaPushSize_</h2><pre>void *
ArenaPushSize_(memory_arena *Arena,         // Target arena
               memory_index SizeInit,       // Initial size required by callee.
               arena_push_params Params)    // Params to be used during the procedure.
</pre><p>Asks our arena for plotting a block of memory determined by initial size and params requirements.</p></div><div id="ArenaPushString" class="doc"><h2>ArenaPushString</h2><pre>char *
ArenaPushString(memory_arena *Arena, // Target arena
                const char *Source)  // String source
</pre><p>Pushes null-terminated string to the arena.</p></div><div id="ArenaPushAndNullTerminate" class="doc"><h2>ArenaPushAndNullTerminate</h2><pre>char *
ArenaPushAndNullTerminate(memory_arena *Arena, // Target arena
                          u32 Length,          // String length
                          const char *Source)  // String source
</pre><p>Pushes string of specified size to the arena and additionally null-terminates it.</p></div><div id="ArenaBeginTemporaryMemory" class="doc"><h2>ArenaBeginTemporaryMemory</h2><pre>temp_memory
ArenaBeginTemporaryMemory(
memory_arena *Arena) // Target arena
</pre><p>Tells our arena we plan to store temporary memory in it.</p></div><div id="ArenaEndTemporaryMemory" class="doc"><h2>ArenaEndTemporaryMemory</h2><pre>void
ArenaEndTemporaryMemory(
temp_memory TempMem) // Structure holding our arena's pointer and originally used size. @see temp_memory
</pre><p>Tells our arena we`re done serving temporary memory and resets it back to its original state.</p></div><div id="ArenaClear" class="doc"><h2>ArenaClear</h2><pre>void
ArenaClear(
memory_arena *Arena) // Target arena
</pre><p>Clears the whole arena.</p></div><div id="ArenaCheck" class="doc"><h2>ArenaCheck</h2><pre>void
ArenaCheck(memory_arena *Arena)
</pre><p>Checks whether our arena is still holding temporary data.</p></div><div id="ArenaSub" class="doc"><h2>ArenaSub</h2><pre>void
ArenaSub(memory_arena *Result,     // Target SubArena
         memory_arena *Arena,      // Target Arena
         memory_index Size,        // Initial size required by callee.
         arena_push_params Params) // Params to be used during the procedure.
</pre><p>Creates sub-arena inside of our arena, with specified size and push params.</p></div><div id="ArenaCleanUnusedRoom" class="doc"><h2>ArenaCleanUnusedRoom</h2><pre>void
ArenaCleanUnusedRoom(
memory_arena * Arena) // Target arena
</pre><p>Clean unused reserved space in our arena.</p></div><div id="ArenaFree" class="doc"><h2>ArenaFree</h2><pre>void
ArenaFree(
memory_arena * Arena) // Target arena
</pre><p>Deallocate our arena.</p></div><div id="ArenaSerialize" class="doc"><h2>ArenaSerialize</h2><pre>u8 *
ArenaSerialize(
memory_arena * Arena, // Arena to be serialized.
 size_t * Size)         // Size of the serialized data.
</pre><p>Serializes our arena</p><p><b>Returns:</b> <i>Returns serialized data.</i></p></div><div id="ArenaDeserialize" class="doc"><h2>ArenaDeserialize</h2><pre>void
ArenaDeserialize(
memory_arena * Arena, // Our new arena to be used for unpacking.
u8 * Data)            // Source of our serialized data.
</pre><p>Deserializes our packed data to our new arena.</p></div><div id="ArenaDuplicate" class="doc"><h2>ArenaDuplicate</h2><pre>void
ArenaFreeBlockID(
memory_arena *Arena,
mi Idx)
</pre><p>Duplicates our arena.</p></div></ul></div></body></html>